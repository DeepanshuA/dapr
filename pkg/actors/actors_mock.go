//go:build unit
// +build unit

/*
Copyright 2023 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by mockery v1.0.0.

package actors

import (
	"context"
	"errors"
	"time"

	mock "github.com/stretchr/testify/mock"

	"github.com/dapr/components-contrib/state"
	actorsCore "github.com/dapr/dapr/pkg/actors/core"
	actorsCoreReminder "github.com/dapr/dapr/pkg/actors/core/reminder"
	"github.com/dapr/dapr/pkg/actors/reminders"
	invokev1 "github.com/dapr/dapr/pkg/messaging/v1"
	runtimev1pb "github.com/dapr/dapr/pkg/proto/runtime/v1"
	daprt "github.com/dapr/dapr/pkg/testing"
)

// MockActors is an autogenerated mock type for the Actors type
type MockActors struct {
	mock.Mock
	actorsReminders actorsCore.Reminders
	actorsTimers    actorsCore.Timers
}

func (_m *MockActors) RegisterInternalActor(ctx context.Context, actorType string, actor actorsCore.InternalActor) error {
	return nil
}

// Call provides a mock function with given fields: req
func (_m *MockActors) Call(ctx context.Context, req *invokev1.InvokeMethodRequest) (*invokev1.InvokeMethodResponse, error) {
	ret := _m.Called(req)

	var r0 *invokev1.InvokeMethodResponse
	if rf, ok := ret.Get(0).(func(*invokev1.InvokeMethodRequest) *invokev1.InvokeMethodResponse); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*invokev1.InvokeMethodResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*invokev1.InvokeMethodRequest) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsActorHosted provides a mock function with given fields: req
func (_m *MockActors) IsActorHosted(ctx context.Context, req *actorsCoreReminder.ActorHostedRequest) bool {
	ret := _m.Called(req)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*actorsCoreReminder.ActorHostedRequest) bool); ok {
		r0 = rf(req)
	} else {
		r0 = true
	}

	return r0
}

// GetState provides a mock function with given fields: req
func (_m *MockActors) GetState(ctx context.Context, req *actorsCoreReminder.GetStateRequest) (*actorsCoreReminder.StateResponse, error) {
	ret := _m.Called(req)

	var r0 *actorsCoreReminder.StateResponse
	if rf, ok := ret.Get(0).(func(*actorsCoreReminder.GetStateRequest) *actorsCoreReminder.StateResponse); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*actorsCoreReminder.StateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*actorsCoreReminder.GetStateRequest) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Init provides a mock function with given fields:
func (_m *MockActors) Init() error {
	ret := _m.Called()
	_m.actorsReminders = new(MockReminders)
	_m.actorsTimers = new(MockTimers)
	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stop provides a mock function with given fields:
func (_m *MockActors) Stop() {
	_m.Called()
}

// TransactionalStateOperation provides a mock function with given fields: req
func (_m *MockActors) TransactionalStateOperation(ctx context.Context, req *actorsCore.TransactionalRequest) error {
	ret := _m.Called(req)

	var r0 error
	if rf, ok := ret.Get(0).(func(*actorsCore.TransactionalRequest) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetActiveActorsCount provides a mock function
func (_m *MockActors) GetActiveActorsCount(ctx context.Context) []*runtimev1pb.ActiveActorsCount {
	_m.Called()
	return []*runtimev1pb.ActiveActorsCount{
		{
			Type:  "abcd",
			Count: 10,
		},
		{
			Type:  "xyz",
			Count: 5,
		},
	}
}

func (_m *MockActors) GetActorsReminders() actorsCore.Reminders {
	return _m.actorsReminders
}

func (_m *MockActors) GetActorsTimers() actorsCore.Timers {
	return _m.actorsTimers
}

type FailingActors struct {
	Failure daprt.Failure
}

func (f *FailingActors) RegisterInternalActor(ctx context.Context, actorType string, actor actorsCore.InternalActor) error {
	return nil
}

func (f *FailingActors) Call(ctx context.Context, req *invokev1.InvokeMethodRequest) (*invokev1.InvokeMethodResponse, error) {
	proto, err := req.ProtoWithData()
	if err != nil {
		return nil, err
	}
	if proto == nil || proto.Actor == nil {
		return nil, errors.New("proto.Actor is nil")
	}
	if err := f.Failure.PerformFailure(proto.Actor.ActorId); err != nil {
		return nil, err
	}
	var data []byte
	if proto.Message != nil && proto.Message.Data != nil {
		data = proto.Message.Data.Value
	}
	resp := invokev1.NewInvokeMethodResponse(200, "Success", nil).
		WithRawDataBytes(data)
	return resp, nil
}

func (f *FailingActors) Init() error {
	return nil
}

func (f *FailingActors) Stop() {
}

func (f *FailingActors) GetState(ctx context.Context, req *actorsCoreReminder.GetStateRequest) (*actorsCoreReminder.StateResponse, error) {
	return nil, nil
}

func (f *FailingActors) TransactionalStateOperation(ctx context.Context, req *actorsCore.TransactionalRequest) error {
	return nil
}

func (f *FailingActors) GetReminder(ctx context.Context, req *actorsCoreReminder.GetReminderRequest) (*actorsCore.Reminder, error) {
	return nil, nil
}

func (f *FailingActors) CreateReminder(ctx context.Context, req *reminders.CreateReminderRequest) error {
	return nil
}

func (f *FailingActors) DeleteReminder(ctx context.Context, req *actorsCoreReminder.DeleteReminderRequest) error {
	return nil
}

func (f *FailingActors) RenameReminder(ctx context.Context, req *actorsCoreReminder.RenameReminderRequest) error {
	return nil
}

func (f *FailingActors) CreateTimer(ctx context.Context, req *reminders.CreateTimerRequest) error {
	return nil
}

func (f *FailingActors) DeleteTimer(ctx context.Context, req *actorsCoreReminder.DeleteTimerRequest) error {
	return nil
}

func (f *FailingActors) IsActorHosted(ctx context.Context, req *actorsCoreReminder.ActorHostedRequest) bool {
	return true
}

func (f *FailingActors) GetActiveActorsCount(ctx context.Context) []*runtimev1pb.ActiveActorsCount {
	return []*runtimev1pb.ActiveActorsCount{}
}

func (f *FailingActors) GetActorsReminders() actorsCore.Reminders {
	return nil
}

func (f *FailingActors) GetActorsTimers() actorsCore.Timers {
	return nil
}

type MockReminders struct {
	mock.Mock
}

// CreateReminder provides a mock function with given fields: req
func (_m *MockReminders) CreateReminder(ctx context.Context, req *reminders.CreateReminderRequest) error {
	ret := _m.Called(req)

	var r0 error
	if rf, ok := ret.Get(0).(func(*reminders.CreateReminderRequest) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetReminder provides a mock function with given fields: req
func (_m *MockReminders) GetReminder(ctx context.Context, req *actorsCoreReminder.GetReminderRequest) (*actorsCore.Reminder, error) {
	ret := _m.Called(req)

	var r0 *actorsCore.Reminder
	if rf, ok := ret.Get(0).(func(*actorsCoreReminder.GetReminderRequest) *actorsCore.Reminder); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*actorsCore.Reminder)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*actorsCoreReminder.GetReminderRequest) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteReminder provides a mock function with given fields: req
func (_m *MockReminders) DeleteReminder(ctx context.Context, req *actorsCoreReminder.DeleteReminderRequest) error {
	ret := _m.Called(req)

	var r0 error
	if rf, ok := ret.Get(0).(func(*actorsCoreReminder.DeleteReminderRequest) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RenameReminder provides a mock function with given fields: req
func (_m *MockReminders) RenameReminder(ctx context.Context, req *actorsCoreReminder.RenameReminderRequest) error {
	ret := _m.Called(req)

	var r0 error
	if rf, ok := ret.Get(0).(func(request *actorsCoreReminder.RenameReminderRequest) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

func (_m *MockReminders) SetStateStore(store actorsCore.TransactionalStateStore) {

}
func (_m *MockReminders) ExecuteStateStoreTransaction(ctx context.Context, store actorsCore.TransactionalStateStore, operations []state.TransactionalStateOperation, metadata map[string]string) error {
	return nil
}
func (_m *MockReminders) StartReminder(reminder *actorsCore.Reminder, stopChannel chan struct{}) error {
	return nil
}
func (_m *MockReminders) ExecuteReminder(reminder *actorsCore.Reminder, isTimer bool) (err error) {
	return nil
}
func (_m *MockReminders) GetActorTypeMetadata(ctx context.Context, actorType string, migrate bool) (*actorsCore.ActorMetadata, error) {
	return nil, nil
}
func (_m *MockReminders) GetReminderTrack(ctx context.Context, key string) (*actorsCoreReminder.ReminderTrack, error) {
	return nil, nil
}
func (_m *MockReminders) UpdateReminderTrack(ctx context.Context, key string, repetition int, lastInvokeTime time.Time, etag *string) error {
	return nil
}

type MockTimers struct {
	mock.Mock
}

// CreateTimer provides a mock function with given fields: req
func (_m *MockTimers) CreateTimer(ctx context.Context, req *reminders.CreateTimerRequest) error {
	ret := _m.Called(req)

	var r0 error
	if rf, ok := ret.Get(0).(func(*reminders.CreateTimerRequest) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTimer provides a mock function with given fields: req
func (_m *MockTimers) DeleteTimer(ctx context.Context, req *actorsCoreReminder.DeleteTimerRequest) error {
	ret := _m.Called(req)

	var r0 error
	if rf, ok := ret.Get(0).(func(*actorsCoreReminder.DeleteTimerRequest) error); ok {
		r0 = rf(req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
